#ifndef EVENT_HPP
#define EVENT_HPP

#include <stdlib.h>
#include <fatcnt/events/catagorizer/cmodes.hpp>
#include <fatcnt/protocols/common/mspdirection.hpp>
#include <fatcnt/protocols/common/mspcommands.hpp>

//TODO: All commands need to be imported here, so that they can be deferenced properly.
#include <fatcnt/protocols/common/curators/rrp/msp_none.hpp>

namespace rrobot {
/**
 *  @brief events are added to queues.
 */
class Event {
   public:
    // constructor for outbound, or requests with a payload.
    Event(MSPCOMMANDS command, MSPDIRECTION direction, void* payload)
        : _command(command), 
          _direction(direction),
          _payload(payload) {
        
        _hasPayload = true;
    }

    // constructor for inbound request, payload is not set.
    Event(MSPCOMMANDS command, MSPDIRECTION direction)        
        : _command(command), 
          _direction(direction) {}

    // TODO:  payload should only be freed using deconstructor. This file needs to be configured.
    ~Event() {
        if (hasPayload()) {
            switch(_command) {
                case MSP_NONE:
                    delete(reinterpret_cast<msp_none*>(_payload));
                    break;
                // MSP_MODE = 1,
                // MSP_ERROR = 2,
                // MSP_AUTHKEY = 7,
                // MSP_SONAR_ALTITUDE = 58,
                // MSP_IDENT = 100,
                // MSP_STATUS = 101,
                // MSP_MOTOR = 104,
                // MSP_SET_MOTOR_HBRIDGE = 215,
                // MSP_SENSOR = 216,
            }
        }
    }

    /**
     * @fn hasPayload
     * @brief
     * returns true if payload has been set (this usually indicates outbound), false if not this will usually indicate
     * inbound.
     */
    bool hasPayload() {return _hasPayload;}

    /**
     * @fn getPayload
     * @brief 
     * Returns the payload
     * @return payload
     */
    template <typename T> T getPayload() {
        return *(reinterpret_cast<T*>(_payload));
    }

    MSPCOMMANDS getCommand() {
        return _command;
    }

    MSPDIRECTION getDirection() {
        return _direction;
    }

   private:
    const MSPCOMMANDS  _command;   // command
    const MSPDIRECTION _direction; // direction of command
    void*              _payload = nullptr;   // payload
    bool               _hasPayload = false;    
};
}  // namespace rrobot

#endif  // EVENT_HPP